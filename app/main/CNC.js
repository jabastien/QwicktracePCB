const path = require('path')
const fs = require('fs')
const EventEmitter = require('events')

const io = require('socket.io-client')
const jwt = require('jsonwebtoken')


// Controller initialization...
function getUserHome() {
    return process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME']
}
  
function generateAccessToken(payload, secret, expiration) {
    const token = jwt.sign(payload, secret, {
      expiresIn: expiration
    })
  
    return token
}
  
const cncrc = path.resolve(getUserHome(), '.cncrc');
  
function getAccessToken() {
    try {
      let config = JSON.parse(fs.readFileSync(cncrc, 'utf8'))
      let secret = config.secret;
      let token = generateAccessToken({ id: '' , name: 'qwicktrace' }, secret, '30d');
      return token;    
    } 
    catch (err) {
      console.error(err)
      process.exit(1)
    }
}

  
const host = '127.0.0.1';
const port = 8000;
const serialPort = '/dev/ttyUSB0';
const baudRate = 115200;
const controllerType = 'Grbl';

const RESERVED_EVENTS = [ 'error', 'ready', 'closed', 'state', 'sent', 'data', 'pos', 'mode', 'workflow' ];

/**
 * A Class for controlling a Grbl based CNC controlled by CNCjs running on the local machine. As
 * an EventEmitter, external listeners can subscribe (and unsubscribe) to events. These are the
 * events emitted directly by this class:
 * <ol>
 *   <li>ready - The class is connected to the controller and ready for further processing</li>
 *   <li>error - An error has occurred</li>
 *   <li>closed - The connection to the controller has been closed</li>
 *   <li>state - A change in the state of the controller (and/or the workflow state)</li>
 *   <li>sent - The data specified in the handler's argument was sent to the controller</li>
 *   <li>data - The data specified in the handler's argument was received from the controller</li>
 * </ol>
 * 
 * In addition to the above primary events, any event defined by CNCjs for its socket communications API
 * can be used.
 */
class CNC extends EventEmitter {

    constructor() {
        super();
        this.token = getAccessToken();
    }

    connect() {
        this.socket = io.connect('ws://' + host + ':' + port, {
            'query': 'token=' + this.token
        });

        let thiz = this;
        this.socket.on('connect', () => {
           let url = 'ws://' + host;
           console.log('Connected to CNCjs at ' + url);
           thiz.socket.emit('open', serialPort, {
              baudrate: Number(baudRate),
              controllerType: controllerType
           });
        });


        this.socket.on('error', (err) => {
            console.error('CNCjs Connection error.', err)
            if (thiz.socket) {
              thiz.socket.destroy();
              thiz.socket = null;
            }
            thiz.emit('error', new Error('Error opening CNCjs connection: "' + err.message));
        });


        this.socket.on('close', () => {
            console.log('Connection to CNCjs closed.');
            thiz.socket = null;
            thiz.emit('closed');
        });
        
        
        this.socket.on('serialport:open', function (options) {
            options = options || {}
            console.log('Connected to port "' + options.port + '" (Baud rate: ' + options.baudrate + ')')

            // Notify the CNC object listeners that we are ready to control the machine.
            thiz.emit('ready');
        });


        this.socket.on('serialport:error', function (options) {
            thiz.emit('error', new Error('Error opening serial port "' + options.port + '"'));
        });
          

        this.socket.on('workflow:state', (state) => {
            thiz.wfState = state;
            this.emit('workflow', state);
        });


        this.socket.on('controller:state', (controller, state) => {
            thiz.ctrlState = state;
            this.emit('mode', state.status.activeState);
            this.emit('pos', { mpos: state.status.mpos, wpos: state.status.wpos, spindle: state.status.spindle });
        });


        this.socket.on('serialport:write', (data) => {
            thiz.emit('sent', data)
        });

        
        this.socket.on('serialport:read', (data) => {
            thiz.emit('data', data);
        });
 
    }

    disconnect() {
        if (this.socket) {
           this.socket.disconnect();
           this.socket = null;
        }
    }


    on(eventName, listener) {

        // Directly handle events generated by this class...
        if (RESERVED_EVENTS.includes(eventName)) {
            return super.on(eventName, listener);
        }

        if (this.socket) {
           // Everything else is assumed low level and handled directly by the socket...
           return this.socket.on(eventName, listener);
        }
        else {
            throw new Error('Subscribing directly to CNCjs events must occur after connect() has been called.');
        }
    }



    removeListener(eventName, listener) {

        // Directly handle events generated by this class...
        if (RESERVED_EVENTS.includes(eventName)) {
            return super.removeListener(eventName, listener);
        }

        // Event alias names for socket events-=-=-=-=-=-=-=-
    
        // When CNC sends commands to Grbl...
        if (eventName === 'sent') {
            // Delegate directly to the socket...
            return this.socket.removeListener('serialport:write', listener);
        }

        // When we receive data from Grbl...
        if (eventName === 'data') {
            return this.socket.removeListener('serialport:read', listener);
        }

        //-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-

        // Everything else is assumed low level and handled directly by the socket...
        return this.socket.removeListener(eventName, listener);
    }

        
    // Possible commands that can be sent to the Grbl controller can be found in CNCjs code
    // src/server/controllers/Grbl/GrblController.js starting at line 1029 (see possible property names
    // of the map value being assigned to 'const handler').
    sendGCode(gcode) {
        if (Array.isArray(gcode)) {
           this.sendCommand('gcode', gcode.join('\n'));
        }
        else {
           this.sendCommand('gcode', gcode);
        }
    }


    stopGcode () {
        this.sendCommand('gcode:stop', { force: true });
    }


    sendCommand(cmd, arg) {
        this.socket.emit('command', serialPort, cmd, arg)
    }

    /**
     * Commands the spindle to jog, but only if the status is idle or in jog mode. Arguments of (0, 0)
     * will immediately cancel any jog in progress.
     */
    jog(stickX, stickY) {
        if (stickX !== 0 || stickY !== 0) {
             let fastestRate = Math.max(Math.abs(stickX), Math.abs(stickY));
             let feedRate = Math.round(500 * fastestRate);
        }
        else {
            if (this.jogInProgress) {
               this.sendCommand('feedhold');
               this.jogInProgress = false;
            }
        }
    }
}


module.exports = CNC;
